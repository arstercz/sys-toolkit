#!/usr/bin/env perl

=head1 NAME

sys-mysql-diff -- compare MySQL database schema, variables and 
privilege at different time

=head1 SYNOPSIS

Usage:  [OPTION...]

=head1 RISKS

  The connect user must all database select privileges so 
  that get table structure info.

  default also to diff global variables.

  Connect user also need have grant option so that can get
  all user privileges when you want to diff user privileges;

=cut

use strict;
use warnings FATAL => 'all';
use Carp;
use Data::Dumper;
use Getopt::Long qw(:config no_ignore_case);
use English '-no_match_vars';

my $host     = '127.0.0.1';
my $port     = 3306;
my $user     = 'root';
my $password = '';
my $askpass  = 0;
my $database = 'information_schema';
my $debug    = 0;
my $tolerant = 0;
my $help     = 0;
my $work     = '/tmp/mysqldiff';
my $charset  = 'utf8';
my $privileges = 0;

GetOptions(
    "host|h=s"     => \$host,
    "port|P=i"     => \$port,
    "user|u=s"     => \$user,
    "password|p=s" => \$password,
    "askpass!"     => \$askpass,
    "database|d=s" => \$database,
    "charset|c=s"  => \$charset,
    "debug|D!"     => \$debug,
    "tolerant|t"   => \$tolerant,
    "work|w=s"     => \$work,
    "help!"        => \$help,
    "privielges|r!"=> \$privileges,
) or die "error:$!";

if ($help) {
    usage($0);
}

sub usage {
    my $name = shift;
    system("perldoc $name");
    exit 0;
}

if ($askpass) {
   $password = noecho_password("Enter password ");
}

if ( !$password ) {
    warn "Can not connect to MySQL without password.";
    usage($0);
    exit 1;
}

# Prompt for password when connecting to MySQL
sub noecho_password {
    my $prompt = shift;
    local $OUTPUT_AUTOFLUSH = 1;
    my $response;
    eval {
        #use Term::ReadKey qw(ReadMode ReadKey);
        require Term::ReadKey;
        Term::ReadKey->import(qw( ReadMode ReadKey ));
        if ($OSNAME =~ m/MSWin/) {
            require Win32::Console::ANSI;
        }
        print "$prompt: ";
        ReadMode('noecho');
        $response = <STDIN>;
        chomp($response);
        ReadMode('normal');
        print "\n" or die 
            "Cannot print: $OS_ERROR";
    };
    if ($EVAL_ERROR) {
        die "Cannot read respose; is Term::ReadKey installed? $EVAL_ERROR";
    }
    return $response;
}

# get db handle
printf( "connect to %s, %d, %s, xxxxxxxx ...\n", $host, $port, $user )
  if $debug;
my $dbpre = MySQL::dbh->new(
    host     => $host,
    port     => $port,
    user     => $user,
    password => $password,
    charset  => $charset,
    driver   => 'mysql',
);
my $dbh = $dbpre->get_dbh( $database, { AutoCommit => 1 } ) or 
                             die "Can't get dbh.. $host:$port";

unless (-e $work) {
    mkdir $work, 0755 or croak "mkdir $work error";
    print "mkdir $work ok\n" if $debug;
}

my $diff_object = MySQL::Diff->new(dbh => $dbh, debug => $debug,
                                   database => $database, tolerant => $tolerant);
my @diffs;

# table schema diff
my $dbm_schema = "$work" . "/dbm-$host-$port-$database";
dbmopen my %hash_table_list, $dbm_schema, 0644
            or die "open $dbm_schema error: $!";

my ($schema_changes, $new_db_table_ref) = $diff_object->schema_diff(\%hash_table_list);
if ($new_db_table_ref) {
    for my $key (keys %hash_table_list) {
        delete $hash_table_list{$key};
    }
    %hash_table_list = %$new_db_table_ref;
}
dbmclose %hash_table_list;

push @diffs, $schema_changes;

# global variables diff
my $dbm_vars = "$work" . "/dbm-$host-$port-variables";
dbmopen my %hash_vars_list, $dbm_vars, 0644
            or die "open $dbm_vars error: $!";

my ($vars_changes, $new_db_vars_ref) = $diff_object->variables_diff(\%hash_vars_list);
if ($new_db_vars_ref) {
    %hash_vars_list = %$new_db_vars_ref;
}
dbmclose %hash_vars_list;

push @diffs, $vars_changes;

# user privileges diff
if($privileges) {
    my $dbm_priv = "$work" . "/dbm-$host-$port-privileges";
    dbmopen my %hash_priv_list, $dbm_priv, 0644
                or die "open $dbm_priv error: $!";
    my ($changes, $new_db_priv_ref) = $diff_object->privileges_diff(\%hash_priv_list);
    if($new_db_priv_ref) {
        %hash_priv_list = %$new_db_priv_ref;
    }
    dbmclose %hash_priv_list;
    push @diffs, $changes;
}

# print diff
foreach my $key (@diffs) {
    print "$key" if $key;
}

# ###################################################################
# Documentation.
# ###################################################################

=head1 OPTIONS

=over 4

=item host=s | h

MySQL host address, default value is '127.0.0.1'

=item port=i | P

MySQL port number. default value is 3306

=item user=s | u

MySQL username. default value is monitor

=item password=s | p

MySQL user password. no default value.

=item askpass

prompt for password options when connect to MySQL.

=item database=s | D

MySQL database will be used, default is 'information_schema', which means compare all databases.


=item charset=s | A

The character used when connect to MySQL, default value is UTF8.

=item debug | d

print debug info.

=item tolerant | t

ignore DEFAULT, AUTO_INCREMENT, COLLATE, and formatting changes, default is false.

=item work | w

the dir that dbm file stored.

=item help

print help info.

=item privileges | r

whether diff user privileges or not, connect user must have grant option privileges.

=back

=head1 AUTHOR

zhe.chen <chenzhe07@gmail.com>

=head1 CHANGELOG

v0.1.0 version

=cut

package MySQL::dbh;

# Get the database handle which user use, and this database
# handle object should be destroy when leave MySQL database.
use strict;
use warnings FATAL => 'all';
use constant PTDEBUG => $ENV{PTDEBUG} || 0;
use English qw(-no_match_vars);
use DBI;
use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);

use Data::Dumper;
$Data::Dumper::Indent    = 1;
$Data::Dumper::Sortkeys  = 1;
$Data::Dumper::Quotekeys = 0;

require Exporter;
@ISA     = qw(Exporter);
@EXPORT  = qw( get_dbh disconnect );
$VERSION = '0.1.0';

eval { require DBI; };

if ($@) {
    die "Cannot connect to MySQL because the Perl DBI module is not "
      . "installed or not found.  Run 'perl -MDBI' to see the directories "
      . "that Perl searches for DBI.  If DBI is not installed, try:\n"
      . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
      . "  RHEL/CentOS    yum install perl-DBI\n"
      . "  OpenSolaris    pkg install pkg:/SUNWpmdbi\n";
}

sub host {
    my $self = shift;
    $self->{host} = shift if @_;
    return $self->{host};
}

sub port {
    my $self = shift;
    $self->{port} = shift if @_;
    return $self->{port};
}

sub user {
    my $self = shift;
    $self->{user} = shift if @_;
    return $self->{user};
}

sub password {
    my $self = shift;
    $self->{password} = shift if @_;
    return $self->{password};
}

sub charset {
    my $self = shift;
    $self->{charset} = shift if @_;
    return $self->{charset};
}

sub driver {
    my $self = shift;
    $self->{driver} = shift if @_;
    return $self->{driver};
}

sub new {
    my ( $class, %args ) = @_;
    my @required_args = qw(host port user password);
    PTDEBUG && print Dumper(%args);

    foreach my $arg (@required_args) {
        warn "I need a $arg argument" unless $args{$arg};
    }

    my $self = {};
    bless $self, $class;

    # options should be used.
    $self->host( $args{'host'}         || 127.0.0.1 );
    $self->port( $args{'port'}         || 3306 );
    $self->user( $args{'user'}         || 'audit' );
    $self->password( $args{'password'} || '' );
    $self->charset( $args{'charset'}   || 'utf8' );
    $self->driver( $args{'driver'}     || 'mysql' );

    return $self;
}

sub get_dbh {
    my ( $self, $database, $opts ) = @_;
    $opts ||= {};
    my $host     = $self->{host};
    my $port     = $self->{port};
    my $user     = $self->{user};
    my $password = $self->{password};
    my $charset  = $self->{charset};
    my $driver   = $self->{driver};

    my $defaults = {
        AutoCommit         => 0,
        RaiseError         => 1,
        PrintError         => 0,
        ShowErrorStatement => 1,
        mysql_enable_utf8  => ( $charset =~ m/utf8/i ? 1 : 0 ),
    };
    @{$defaults}{ keys %$opts } = values %$opts;

    #if ( $opts->{mysql_use_result} ) {
    #    $defaults->{mysql_use_result} = 1;
    #}

    my $dbh;
    my $tries = 2;
    while ( !$dbh && $tries-- ) {
        PTDEBUG
          && print Dumper(
            join( ', ', map { "$_=>$defaults->{$_}" } keys %$defaults ) );
        $dbh = eval {
            DBI->connect(
                "DBI:$driver:database=$database;host=$host;port=$port",
                $user, $password, $defaults );
        };

        if ( !$dbh && $@ ) {
            if ( $@ =~ m/locate DBD\/mysql/i ) {
                warn
                    "Cannot connect to MySQL because the Perl DBD::mysql module is "
                  . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
                  . "the directories that Perl searches for DBD::mysql.  If "
                  . "DBD::mysql is not installed, try:\n"
                  . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
                  . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
                  . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
            }
            elsif ( $@ =~ m/not a compiled character set|character set utf8/i )
            {
                PTDEBUG && print 'Going to try again without utf8 support\n';
                delete $defaults->{mysql_enable_utf8};
            }
            if ( !$tries ) {
                warn "$@";
                return;
            }

        }
    }

    if ( $driver =~ m/mysql/i ) {
        my $sql;
        $sql = 'SELECT @@SQL_MODE';
        PTDEBUG && print "+-- $sql\n";

        my ($sql_mode) = eval { $dbh->selectrow_array($sql) };
        warn "Error getting the current SQL_MORE: $@" if $@;

        if ($charset) {
            $sql = qq{/*!40101 SET NAMES "$charset"*/};
            PTDEBUG && print "+-- $sql\n";
            eval { $dbh->do($sql) };
            warn "Error setting NAMES to $charset: $@" if $@;
            PTDEBUG && print "Enabling charset to STDOUT\n";
            if ( $charset eq 'utf8' ) {
                binmode( STDOUT, ':utf8' )
                  or warn "Can't binmode(STDOUT, ':utf8'): $!\n";
            }
            else {
                binmode(STDOUT) or warn "Can't binmode(STDOUT): $!\n";
            }
        }

        $sql =
            'SET @@SQL_QUOTE_SHOW_CREATE = 1'
            . '/*!40101, @@SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO'
            . ( $sql_mode ? ",$sql_mode" : '' ) . '\'*/';
        PTDEBUG && print "+-- $sql\n";
        eval { $dbh->do($sql) };
        warn "Error setting SQL_QUOTE_SHOW_CREATE, SQL_MODE"
             . ( $sql_mode ? " and $sql_mode" : '' ) . ": $@"
           if $@;
    }

    if (PTDEBUG) {
        print Dumper(
            $dbh->selectrow_hashref(
                'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038, @@hostname*/'
            )
        );
        print "+-- 'Connection info:', $dbh->{mysql_hostinfo}\n";
        print Dumper(
            $dbh->selectall_arrayref(
                "SHOW VARIABLES LIKE 'character_set%'",
                { Slice => {} }
            )
        );
        print '+-- $DBD::mysql::VERSION:' . "$DBD::mysql::VERSION\n";
        print '+-- $DBI::VERSION:' . "$DBI::VERSION\n";
    }
    return $dbh;
}

# handle should be destroy.
sub disconnect {
    my ( $self, $dbh ) = @_;
    PTDEBUG && $self->print_active_handles( $self->get_dbh );
    $dbh->disconnect;
}

sub print_active_handles {
    my ( $self, $thing, $level ) = @_;
    $level ||= 0;
    printf(
        "# Active %sh: %s %s %s\n",
        ( $thing->{Type} || 'undef' ),
        "\t" x $level,
        $thing,
        ( ( $thing->{Type} || '' ) eq 'st' ? $thing->{Statement} || '' : '' )
    ) or warn "Cannot print: $OS_ERROR";
    foreach my $handle ( grep { defined } @{ $thing->{ChildHandles} } ) {
        $self->print_active_handles( $handle, $level + 1 );
    }
}

1;

package MySQL::Priv;
use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Carp qw(croak);
use Data::Dumper;

sub new {
    my ($class, %args) = @_;
    my @required_args = qw(user);
    foreach my $arg (@required_args) {
        die "I need a $arg argument" unless $args{$arg};
    }
    my $self = {
        priv  => undef,
        user  => undef,
    };
    bless $self, $class;
    $self->{priv}     = $args{'priv'};
    $self->{username} = $args{'user'};
    $self->{debug}    = $args{'debug'};
    $self->_parse();
    return $self;
}

sub has_password {
    my $self = shift;
    return length($self->{user}{password}) > 0 ? 1 : 0;
}

sub priv_password {
    my $self = shift;
    return $self->{user}{password};
}

sub priv_options {
    my $self = shift;
    return $self->{user}{with};
}

sub priv_username {
    my $self = shift;
    return $self->{username};
}

sub priv_def {
    my $self = shift;
    return $self->{priv_def};
}

sub priv_dbs {
    my $self = shift;
    my @dbs;
    foreach my $key (keys %{$self->{user}}) {
        if ( ($key eq "password") or ($key eq "with") ) {
            next;
        }
        push @dbs, $key;
    }
    return \@dbs;
}

sub priv_db_priv {
    my ($self, $db) = @_;
    return $self->{user}{$db}{priv};
}

sub _debug_message {
   my $self = shift;
   my $message = shift;
   if ($self->{debug}) {
      print "$message\n";
   }
}

sub _parse_user_priv {
    my $priv = shift;
    my $hash_priv;
    for my $item ( split(/, /, $priv) ) {
        $hash_priv->{$item} = 1;
    }
    return $hash_priv;
}

sub _parse_with {
    my $with = shift;
    my $hash_with;
    my @options = split(/\s+/, $with);
    while( my($key, $val) = splice(@options, 0, 2) ) {
        if ($key =~ /GRANT/i) {
            $hash_with->{"$key $val"} = 1;
        }
        else {
            $hash_with->{$key} = $val;
        }
    }
    return $hash_with;
}

sub _parse {
    my $self = shift;
    $self->{priv_def} = $self->{priv};
    $self->{priv_def} =~ s/`([^`]+)`/$1/gs;
    $self->{priv_def} =~ s/\n+/\n/;
    $self->{lines} = [ grep ! /^\s*$/, split /(?=^)/m, $self->{priv_def} ];

    my @lines = @{$self->{lines}};
    $self->_debug_message("parsing privilege '$self->{priv_def}'");
    my $user = $self->{username};
    while(@lines) {
        $_ = shift @lines;
        s/^\s*(.*?),?\s*$/$1/g;
        if(/GRANT (.+?) ON (.+?) TO (.+)/i) {
            my $db = $2;
            $self->{user}{$db}{priv} = _parse_user_priv($1);
            $self->{user}{password} ||= "";
            $self->{user}{with} ||= "";
            if($3 =~ /IDENTIFIED BY PASSWORD (.+)/i){
                my $passinfo = $1;
                if ($passinfo =~ /(.+?) WITH (.+)/i) {
                    $self->{user}{password} = $1;
                    $self->{user}{with} = _parse_with($2);
                }
                else {
                    $self->{user}{password} = $passinfo;
                }
            }
        }

    } 
}

1;

package MySQL::Table;
use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Carp qw(croak);
use Data::Dumper;

sub new {
    my ( $class, %args ) = @_;
    my @required_args = qw(def);
    foreach my $arg (@required_args) {
        die "I need a $arg argument" unless $args{$arg};
    }
    my $self = {
        def    => undef,
    };
    bless $self, $class;
    $self->{def}  = $args{'def'};
    $self->{debug} = $args{'debug'};
    $self->_parse();
    return $self;
}

sub table_def {
    my $self = shift;
    return $self->{table_def};
}

sub table_name {
    my $self = shift;
    return $self->{table_name};
}

sub table_field {
    my $self = shift;
    return $self->{table_fields}{$_[0]};
}

sub table_fields {
    my $self = shift;
    return $self->{table_fields};
}

sub table_primary_key {
    my $self = shift;
    return $self->{table_primary_key};
}

sub table_indices {
    my $self = shift;
    return $self->{table_indices};
}

sub table_options {
    my $self = shift;
    return $self->{table_options};
}

sub table_foreign_key {
    my $self = shift;
    return $self->{table_foreign_key};
}

sub is_field {
    my $self = shift;
    return $_[0] && $self->{table_fields}{$_[0]} ? 1 : 0;
}

sub is_primary {
    my $self = shift;
    return $_[0] && $self->{table_primary}{$_[0]} ? 1 : 0;
}

sub is_index {
    my $self = shift;
    return $_[0] && $self->{table_indices}{$_[0]} ? 1 : 0;
}

sub is_unique {
    my $self = shift;
    return $_[0] && $self->{table_unique}{$_[0]} ? 1 : 0;
}

sub is_fulltext {
    my $self = shift;
    return $_[0] && $self->{table_fulltext}{$_[0]} ? 1 : 0;
}

sub is_auto_inc {
    my $self = shift;
    return $_[0] && $self->{table_auto_inc}{$_[0]} ? 1 : 0;
}

sub _parse {
    my $self = shift;

    $self->{table_def} = $self->{def};
    $self->{table_def} =~ s/`([^`]+)`/$1/gs;
    $self->{table_def} =~ s/\n+/\n/;
    $self->{lines} = [ grep ! /^\s*$/, split /(?=^)/m, $self->{def} ];

    if ($self->{debug}) {
        print "parsing table def: '$self->{table_def}'\n";
    }
    my @lines = @{$self->{lines}};
    @lines = grep ! m{^/\*!40\d{3} .*? \*/;}, @lines;
    @lines = grep ! m{^(SET |DROP TABLE)}, @lines;

    if ($lines[0] =~ /^\s*create\s+table\s+(\S+)\s+\(\s*$/i) {
        $self->{table_name} = $1;
        shift @lines;
    }
    else {
        croak "couln't figure out table name";
    }

    while (@lines) {
        $_ = shift @lines;
        s/^\s*(.*?),?\s*$/$1/; # trim whitespace and trailing commas
        if (/^PRIMARY\s+KEY\s+(.+)$/) {
            my $primary = $1;
            if ($self->{table_primary_key}) {
                croak "two primary keys in table " . 
                      "'$self->{table_name}': '$primary', '$self->{table_primary_key}'\n";
            }
            $self->{table_primary_key} = $primary;
            $primary =~ s/\((.*?)\)/$1/;
            $self->{table_primary}{$_} = 1 for (split(/,/, $primary));
            next;
        }

        if (/^(?:CONSTRAINT\s+(.*)?)?\s+FOREIGN\s+KEY\s+(.*)$/) {
            my ($key, $val) = ($1, $2);
            if ($self->{table_foreign_key}{$key}) {
                croak "foreign key '$key' duplicated in table '$self->{table_name}'\n";
            }
            $self->{table_foreign_key}{$key} = $val;
            next;
        }

        if (/^(KEY|UNIQUE(?: KEY)?)\s+(\S+?)(?:\s+USING\s+(?:BTREE|HASH|RTREE))?
            \s*\((.*)\)(?:\s+USING\s+(?:BTREE|HASH|RTREE))?$/x) {
            my ($type, $key, $val) = ($1, $2, $3);
            if ($self->{table_indices}{$key}) {
                croak "index '$key' duplicated in table '$self->{table_name}'\n";
            }
            $self->{table_indices}{$key} = $val;
            $self->{table_unique}{$key} = 1 if $type =~ /unique/i;
            next;
        }

        if (/^(FULLTEXT(?:\s+KEY|INDEX)?)\s+(\S+?)\s*\((.*)\)$/) {
            my ($type, $key, $val) = ($1, $2, $3);
            if ($self->{table_fulltext}{$key}) {
                croak "FULLTEXT index '$key' duplicated in table '$self->{table_name}'"
            }
            $self->{table_indices}{$key} = $val;
            $self->{table_fulltext}{$key} = 1;
            next;
        }

        if (/^\)\s*(.*?)$/) { # end of table definition
            $self->{table_options} = $1;
            last;
        }

        if (/^(\S+)\s*(.*)/) {
            my($field, $fdef) = ($1, $2);
            if ($self->{table_fields}{field}) {
                croak "definition for field '$field' duplicated in "
                      . "table '$self->{table_name}'";
            }
            $self->{table_fields}{$field} = $fdef;
            next unless $fdef =~ /\s+AUTO_INCREMENT\b/;
            $self->{table_auto_inc}{$field} = 1;
            next;
        }

        croak "unparsable line in definition for table $self->{table_name}:\n$_";
    }
    warn "table '$self->{table_name}' didn't have terminator\n"
        unless defined $self->{table_options};
    warn "table '$self->{table_name}' had trailing garbage:\n", join '', @lines
        if @lines;

    if ($self->{debug}) {
        printf Dumper($self);
    }
}

# schema diff compare
package MySQL::Diff;
use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Carp qw(croak);
use Data::Dumper;

#general sql list
use constant Get_One_Database_Tables   => "SELECT TABLE_SCHEMA, TABLE_NAME
FROM information_schema.tables WHERE TABLE_SCHEMA = ?";

use constant Get_All_Database_Tables   => "SELECT TABLE_SCHEMA, TABLE_NAME
FROM information_schema.tables WHERE TABLE_SCHEMA NOT IN 
(\"mysql\", \"test\", \"information_schema\", \"performance_schema\")";

use constant Get_All_User_Priv => "SELECT user, host FROM mysql.user";

sub new {
    my ( $class, %args ) = @_;
    my @required_args = qw(dbh database);
    foreach my $arg (@required_args) {
        die "I need a $arg argument" unless $args{$arg};
    }
    my $self = {
        dbh           => undef,
        debug         => undef,
        database      => undef,
        tolerant      => undef,
    };
    bless $self, $class;
    $self->{dbh}        = $args{'dbh'};
    $self->{debug}      = $args{'debug'};
    $self->{database}   = $args{'database'};
    $self->{tolerant}   = $args{'tolerant'};
    return $self;
}

sub get_variable {
    my $self  = shift;
    my $query = shift;
    my $sth   = $self->{dbh}->prepare($query);
    $sth->execute();
    my $href = $sth->fetchrow_hashref;
    return $href->{Value};
}

sub set_variable {
    my $self  = shift;
    my $query = shift;
    eval {
        $self->{dbh}->do($query);
    };
    if($@) {
        return 0;
    }
    else {
        return 1;
    }
}

sub _debug_message {
    my $self = shift;
    my $message = shift;
    if ($self->{debug}) {
        print "$message\n";
    }
}

sub _get_table_structure {
    my $self = shift;
    my $database = shift;
    my $table = shift;
    my $query = sprintf("SHOW CREATE TABLE %s\.%s", $database, $table);
    my $sth = $self->{dbh}->prepare($query);
    $sth->execute();
    my $href = $sth->fetchrow_hashref;
    return $href->{'Create Table'};
}

sub _get_tables_ref {
    my $self = shift;
    if ($self->get_variable("SELECT \@\@global.innodb_stats_on_metadata As Value")) {
        if ($self->set_variable("SET GLOBAL innodb_stats_on_metadata = 0")) {
            $self->_debug_message("execute query: 'set global innodb_stats_on_metadata = 0'");
        }
    }
    my %db_table;
    my $sth = do {
        if ($self->{database} =~ /\binformation_schema\b/i) {
            $self->{dbh}->selectall_arrayref(Get_All_Database_Tables, undef);
        }
        else {
            $self->{dbh}->selectall_arrayref(Get_One_Database_Tables,
                                            undef, $self->{database});
        }
    };
    for my $list (@$sth) {
        my ($db, $table) = @$list;
        $db_table{"$db:$table"} = $self->_get_table_structure($db, $table);
    }
    return \%db_table;
}

sub register_table {
    my($self, $table) = @_;
    return MySQL::Table->new(def=> $table, debug => $self->{debug});
}

sub _get_global_variables_ref {
    my $self = shift;
    my $sth_variables = $self->{dbh}->selectall_arrayref("SHOW GLOBAL VARIABLES")
                            or warn $self->{dbh}->errstr;
    my %global_variables;
    foreach my $list (@$sth_variables) {
        my ($key, $value) = @$list;
        $value ||= '';
        $global_variables{$key} = $value . ''; # ensure string value
    }
    return \%global_variables;
}

sub variables_diff {
    my $self = shift;
    my $old_variables_ref = shift; # Variable_name -> Value
    my @changes;
    
    my $new_variables_ref = $self->_get_global_variables_ref();
    for my $key (keys %$new_variables_ref) {
        $self->_debug_message("comparing variables...$key");
        if ($self->{tolerant}) {
            next if $key eq 'gtid_executed';
        }
        if ($old_variables_ref->{$key}) {
            if($old_variables_ref->{$key} ne $new_variables_ref->{$key}) {
               push @changes, "SET GLOBAL $key = $new_variables_ref->{$key};\n";
            }
        } else {
            #initianal get keys
            $self->_debug_message("add variables $key ...");
        }
    }
    my $out = '';
    if (@changes) {
        $out = join '', @changes;
    }
    return ($out, $new_variables_ref);
}

sub schema_diff {
    my $self = shift;
    my $old_table_ref = shift; # key --> db:table
    my @changes;
    my $database = $self->{database};
    $self->_debug_message("comparing database '$database'");
    my $new_db_table = $self->_get_tables_ref();

    for my $key (keys %$old_table_ref) {
        my $table_old = $self->register_table($old_table_ref->{$key});
        my $name = $table_old->table_name();
        $self->_debug_message("looking at tables called '$name'");
        if (exists $new_db_table->{$key}) {
            $self->_debug_message("comparing tables called '$name'");
            my $table_new = $self->register_table($new_db_table->{$key});
            push @changes, $self->_diff_tables($table_old, $table_new);
        }
        else {
            $self->_debug_message("table '$name' dropped");
            push @changes, "DROP TABLE $name;\n";
        }
    }

    for my $list (keys %$new_db_table) {
        my $table_new = $self->register_table($new_db_table->{$list});
        my $name = $table_new->table_name();
        if (! $old_table_ref->{$list}) {
            $self->_debug_message(sprintf("table '$name' added:\n%s", $table_new->table_def));
            push @changes, $table_new->table_def . "\n";
        }
    }

    my $out = '';
    if (@changes) {
        $out = join '', @changes;
    }
    return ($out, $new_db_table);
}


sub _diff_tables {
    my $self = shift;
    my @changes = (
        $self->_diff_fields(@_),
        $self->_diff_indices(@_),
        $self->_diff_primary_key(@_),
        $self->_diff_foreign_key(@_),
        $self->_diff_options(@_),
    );

    $changes[-1] =~ s/\n*$/\n/ if (@changes);
    return @changes;
}

sub _diff_fields {
    my ($self, $table1, $table2) = @_;
    my $name1 = $table1->table_name();
    my $fields1 = $table1->table_fields();
    my $fields2 = $table2->table_fields();

    return () unless $fields1 || $fields2;
    my @changes;

    if ($fields1) {
        for my $field (keys %$fields1) {
            my $f1 = $fields1->{$field};
            my $f2 = $fields2->{$field};
            if ($fields2 && $f2) {
                if ($self->{tolerant}) {
                    for ($f1, $f2) {
                        s/ COLLATE [\w_]+//gi;
                    }
                }
                if ($f1 ne $f2) {
                    if (not $self->{tolerant} or (($f1 !~ m/$f2\(\d+,\d+\)/) and
                         ($f1 ne "$f2 DEFAULT '' NOT NULL") and
                         ($f1 ne "$f2 NOT NULL") ))
                    {
                        $self->_debug_message("field '$field' changed in table: '$name1'");
                        my $change = "ALTER TABLE $name1 CHANGE COLUMN " 
                                   . "$field $field $f2;";
                        $change .= "\n";
                        push @changes, $change;
                    }
                }
            }
            else {
                $self->_debug_message("field '$field' removed");
                my $change = "ALTER TABLE $name1 DROP COLUMN $field;";
                $change .= "\n";
                push @changes, $change;
            }
        }
    }

    if ($fields2) {
        for my $field (keys %$fields2) {
            unless($fields1 && $fields1->{$field}) {
                $self->_debug_message("field '$field' added");
                my $changes = "ALTER TABLE $name1 ADD COLUMN $field $fields2->{$field};";
                if ($table2->is_auto_inc($field)) {
                    if ($table2->is_primary($field)) {
                        $changes .= " PRIMARY KEY";
                    }
                    elsif ($table2->is_unique($field)) {
                        $changes .= " UNIQUE KEY";
                    }
                }
                push @changes, "$changes;\n";
            }
        }
    }

    return @changes;
}

sub _diff_indices {
    my($self, $table1, $table2) = @_;
    my $name1 = $table1->table_name();
    my $indices1 = $table1->table_indices();
    my $indices2 = $table2->table_indices();

    return () unless $indices1 || $indices2;

    my @changes;
    if ($indices1) {
        for my $index (keys %$indices1) {
            $self->_debug_message("table1 had index '$index'");
            my $old_type = $table1->is_unique($index) 
                         ? 'UNIQUE'
                         : $table1->is_fulltext($index)
                         ? 'FULLTEXT INDEX'
                         : 'INDEX';
            if ($indices2 && $indices2->{$index}) {
                if ( ($indices1->{$index} ne $indices2->{$index}) or 
                     ($table1->is_unique($index) xor $table2->is_unique($index)) or
                     ($table1->is_fulltext($index) xor $table2->is_fulltext($index)) )
                {
                   $self-> _debug_message("index '$index' changed");
                    my $new_type = $table2->is_unique($index) 
                                 ? 'UNIQUE'
                                 : $table2->is_fulltext($index)
                                 ? 'FULLTEXT INDEX'
                                 : 'INDEX';
                    my $changes = "ALTER TABLE $name1 DROP INDEX $index;";
                    $changes .= "\nALTER TABLE $name1 ADD $new_type $index ($indices2->{$index});\n";
                    push @changes, $changes;
                }
            }
            else {
                $self->_debug_message("index '$index' removed");
                my $auto = _check_for_auto_col($table2, $indices1->{$index}, 1) || '';
                my $changes = $auto ? _index_auto_col($table1, $indices1->{$index}) : '';
                $changes = "ALTER TABLE $name1 DROP INDEX $index;";
                $changes .= "\n";
                push @changes, $changes;
            }
        }
    }

    if ($indices2) {
        for my $index (keys %$indices2) {
            next if ($indices1 && $indices1->{$index});
            next if (
                !$table2->is_primary($index)
                && $table2->is_unique($index)
                && _key_covers_auto_col($table2, $index)
            );
            $self->_debug_message("index '$index' added");
            my $new_type = $table2->is_unique($index) ? 'UNIQUE' : 'INDEX';
            push @changes, "ALTER TABLE $name1 ADD $new_type $index ($indices2->{$index});\n";
        }
    }
    return @changes;
}

sub _fields_from_key {
    my $key = shift;
    $key =~ s/^\s*\((.*)\)\s*$/$1/g; # strip brackets if any
    split /\s*,\s*/, $key;
}

sub _check_for_auto_col {
    my ($table, $fields, $primary) = @_;
    my @fields = _fields_from_key($fields);
    for my $field (@fields) {
        next if ($table->table_field($field) !~ /auto_increment/i);
        next if ($table->is_index($field));
        next if ($primary && $table->is_primary($field));

        return $field;
    }
    return;
}

sub _key_covers_auto_col {
    my ($table, $key) = @_;
    my @fields = _fields_from_key($key);
    for my $field (@fields) {
        return 1 if $table->is_auto_inc($field);
    }
    return;
}

sub _index_auto_col {
    my ($table, $field) = @_;
    my $name = $table->table_name();
    return 
        "ALTER TABLE $name ADD INDEX ($field); #auto columns must always be indexed\n";
}

sub _diff_primary_key {
    my ($self, $table1, $table2) = @_;
    my $name1 = $table1->table_name();

    my $primary1 = $table1->table_primary_key();
    my $primary2 = $table2->table_primary_key();

    return () unless $primary1 || $primary2;

    my @changes;
    if ($primary1 && ! $primary2) {
        $self->_debug_message("primary key '$primary1' dropped");
        my $changes .= _index_auto_col($table2, $primary1);
        $changes = "ALTER TABLE $name1 DROP PRIMARY KEY;\n";
        push @changes, $changes;
    }

    if (! $primary1 && $primary2) {
        $self->_debug_message("primary key '$primary2' added");
        return () if _key_covers_auto_col($table2, $primary2);
        push @changes, "ALTER TABLE $name1 ADD PRIMARY KEY $primary2;\n";
    }

    if ($primary1 ne $primary2) {
        $self->_debug_message("primary key changed");
        my $auto = _check_for_auto_col($table2, $primary1) || '';
        my $changes = $auto ? _index_auto_col($table2, $auto) : '';
        $changes .= "ALTER TABLE $name1 DROP PRIMARY KEY;";
        $changes .= "\nALTER TABLE $name1 ADD PRIMARY KEY $primary2;\n";
        $changes .= "ALTER TABLE $name1 DROP INDEX $auto;\n" if ($auto);
        push @changes, $changes;
    }

    return @changes;
}

sub _diff_foreign_key {
    my ($self, $table1, $table2) = @_;

    my $name1 = $table1->table_name();
    my $fks1 = $table1->table_foreign_key();
    my $fks2 = $table2->table_foreign_key();

    return () unless $fks1 || $fks2;

    my @changes;
    if ($fks1) {
        for my $fk (keys %$fks1) {
            $self->_debug_message("$name1 has fk '$fk'");
            if ($fks2 && $fks2->{$fk}) {
                if ($fks1->{$fk} ne $fks2->{$fk} ) {
                    $self->_debug_message("foreign key '$fk' changed");
                    my $changes = "ALTER TABLE $name1 DROP FOREIGN KEY $fk;";
                    $changes .= "\nALTER TABLE $name1 ADD CONSTRAINT $fk FOREIGN KEY $fks2->{$fk};\n";
                    push @changes, $changes;
                }
            }
            else {
                $self->_debug_message("foreign key '$fk' removed");
                my $changes = "ALTER TABLE $name1 DROP FOREIGN KEY $fk;";
                $changes .= "\n";
                push @changes, $changes;
            }
        }
    }

    if($fks2) {
        for my $fk (keys %$fks2) {
            next if ($fks1 && $fks1->{$fk});
            $self->_debug_message("foreign key '$fk' added");
            push @changes, "ALTER TABLE $name1 ADD CONSTRAINT $fk FOREIGN KEY $fks2->{$fk};\n";
        }
    }
    return @changes;
}

sub _diff_options {
    my ($self, $table1, $table2) = @_;
    my $name = $table1->table_name();
    my $options1 = $table1->table_options();
    my $options2 = $table2->table_options();

    return () unless $options1 || $options2;

    my @changes;
    if ($self->{tolerant}) {
        for ($options1, $options2) {
            s/ AUTO_INCREMENT=\d+//gi;
            s/ COLLATE=[\w_]+//gi;
        }
    }
    if ($options1 ne $options2) {
        my $change = "ALTER TABLE $name $options2;";
        $change .= "\n";
        push @changes, $change;
    }
    return @changes;
}

# privileges diff
sub _get_user_priv {
    my ($self, $user, $host) = @_;
    my $out = '';
    my $sth;
    eval {
        $sth  = $self->{dbh}->selectcol_arrayref("SHOW GRANTS FOR \'$user\'\@\`$host\`");
    };
    unless ($@) {
        foreach my $item (@$sth) {
            chomp($item);
            $out .= $item . "\n";
        }
    }
    return $out;
}

sub _get_all_user_priv_ref {

    my $self = shift;

    my %hash_user_priv;
    my $sth = $self->{dbh}->selectall_arrayref(Get_All_User_Priv);
    foreach my $list (@$sth) {
        my ($user, $host) = @$list;
        $hash_user_priv{"\'$user\'\@\'$host\'"} = $self->_get_user_priv($user, $host);
    }
    return \%hash_user_priv;
}

sub register_priv {
    my ($self, $user, $priv) = @_;
    return MySQL::Priv->new(user => $user, priv => $priv, debug => $self->{$debug});
}

sub privileges_diff {
    my $self = shift;
    my $old_priv_ref = shift; # user --> privileges in one line
    my @changes;
    $self->_debug_message("comparing user privileges");
    my $new_priv_ref = $self->_get_all_user_priv_ref();

    for my $key (keys %$old_priv_ref) {
        my $priv_old = $self->register_priv($key, $old_priv_ref->{$key});
        my $user = $priv_old->priv_username();
        if (exists $new_priv_ref->{$key}) {
            $self->_debug_message("comparing for user '$user'");
            my $priv_new = $self->register_priv($key, $new_priv_ref->{$key});
            push @changes, $self->_diff_priv($priv_old, $priv_new);
        }
        else {
            $self->_debug_message("user '$user' dropped");
            push @changes, "DROP USER $user;\n";
        }
    }

    for my $key (keys %$new_priv_ref) {
        my $priv_new = $self->register_priv($key, $new_priv_ref->{$key});
        my $user = $priv_new->priv_username();
        if (! $old_priv_ref->{$key}) {
            $self->_debug_message("priv for '$user' added: \n$priv_new->priv_def");
            push @changes, $priv_new->priv_def;
        }
    }

    my $out = '';
    if (@changes) {
        $out = join '', @changes;
    }
    return ($out, $new_priv_ref);
}

sub _diff_priv {
    my $self = shift;
    my @changes = (
        $self->_diff_priv_password(@_),
        $self->_diff_priv_with(@_),
        $self->_diff_priv_dbs(@_),
    );
    $changes[-1] =~ s/\n*$/\n/ if (@changes);
    return @changes;
}

sub _diff_priv_password {
    my ($self, $priv1, $priv2) = @_;
    my $user1 = $priv1->priv_username();
    my $password1 = $priv1->priv_password() || "";
    my $password2 = $priv2->priv_password() || "";

    my @changes;
    $self->_debug_message("comparing '$user1' password...");
    if ($password1 ne $password2) {
        push @changes, "SET PASSWORD FOR $user1 = $password2;\n";
    }
    return @changes;
}

sub _diff_priv_with {
    my ($self, $priv1, $priv2) = @_;
    my $user1 = $priv1->priv_username();
    my $with1 = $priv1->priv_options();
    my $with2 = $priv2->priv_options();

    return () unless $with1 || $with2;
    my @changes;

    if ($with1) {
        for my $key (keys %$with1) {
            $self->_debug_message("priv1 had options '$key'");
            if ($with2 && $with2->{$key}) {
                # ...... WITH GRANT OPTION MAX_CONNECTIONS_PER_HOUR 50
                if ($key ne "GRANT OPTION") {
                    push @changes, "GRANT usage ON *.* TO $user1 WITH $key $with2->{$key};\n";
                }
            }
            else {
                if ($key eq "GRANT OPTION") {
                    push @changes, "REVOKE GRANT OPTION ON *.* FROM $user1;\n";
                }
                else {
                    push @changes, "GRANT usage ON *.* TO $user1 WITH $key 0;\n";
                }
            }
        }
    }

    if ($with2) {
        for my $key (keys %$with2) {
            unless ($with1 && $with1->{$key}) {
                $self->_debug_message("priv '$key' added");
                if ($key eq "GRANT OPTION") {
                    push @changes, "GRANT GRANT OPTION ON *.* TO $user1;\n";
                }
                push @changes, "GRANT usage ON *.* TO $user1 WITH $key $with2->{$key};\n";
            }
        }
    }

    return @changes;
}

sub _diff_priv_dbs {
    my ($self, $priv1, $priv2) = @_;
    my $user1 = $priv1->priv_username();
    my $db1 = $priv1->priv_dbs();
    my $db2 = $priv2->priv_dbs();

    return () unless $db1 || $db2;

    my @changes;
    $self->_debug_message("comparing db privileges for user $user1");
    for my $db (@$db1) {
        my @priv_items;
        my $db1_priv = $priv1->priv_db_priv($db);
        my $db2_priv = $priv2->priv_db_priv($db);
        for my $list (keys %$db1_priv) {
            unless (exists $db2_priv->{$list}) {
                if ($list =~ /ALL PRIVILEGES/) {
                    push @priv_items, "ALL PRIVILEGES";
                    last;
                }
                else {
                    push @priv_items, $list;
                }
            }
        }
        my $change = do {
            if ($priv_items[0] && $priv_items[0] eq "ALL PRIVILEGES") {
                my $privs = join ',', (keys %$db2_priv);
                my $priv_sql = "REVOKE ALL PRIVILEGES ON $db FROM $user1;\n";
                $priv_sql .= length($privs) > 0
                           ? "GRANT $privs ON $db TO $user1;\n"
                           : "";
                return $priv_sql;
            }
            elsif (@priv_items) {
                my $privs = join ', ', @priv_items;
                #skip revoke if new priv is all privileges
                unless (exists $db2_priv->{"ALL PRIVILEGES"}) {
                    "REVOKE $privs ON $db FROM $user1;\n";
                }
                else {
                    ""
                }
            }
            else {}
        };
        if ($change) {
            push @changes, $change;
        }
   }

   for my $db (@$db2) {
        my @priv_items;
        my $db1_priv = $priv1->priv_db_priv($db);
        my $db2_priv = $priv2->priv_db_priv($db);
        for my $list (keys %$db2_priv) {
            unless (exists $db1_priv->{$list}) {
                if ($list =~ /ALL PRIVILEGES/) {
                    push @priv_items, "ALL PRIVILEGES";
                    last;
                }
                else {
                    push @priv_items, $list;
                }
            }
        }
        my $change = do {
            if ($priv_items[0] && $priv_items[0] eq "ALL PRIVILEGES") {
                "GRANT ALL PRIVILEGES ON $db TO $user1;\n";
            }
            elsif (@priv_items) {
                my $privs = join ', ', @priv_items;
                length($privs) > 0
                        ? "GRANT $privs ON $db TO $user1;\n"
                        : "";
            }
            else {}
        };
        if ($change) {
            push @changes, $change;
        }
   }

   return @changes;
}

1;
